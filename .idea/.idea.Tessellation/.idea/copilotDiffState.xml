<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/PULL_REQUEST_SaveLoad.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/PULL_REQUEST_SaveLoad.md" />
              <option name="updatedContent" value="---&#10;&lt;!-- &#10;   양식 : 'PR타입 : 제목'&#10;   타입은 대문자로 적어야한다. 예) FEAT/FIX/REFACTOR&#10;--&gt;&#10;#  FEAT : 세이브/로드 시스템 구현&#10;&#10;##  개요&#10;게임 데이터를 저장하고 불러오는 세이브/로드 시스템과 히스토리 관리 시스템을 구현했습니다.&#10;- `ISaveTarget` 인터페이스를 통한 저장 가능 객체 관리&#10;- `GameData` 구조체를 통한 통합 데이터 관리&#10;- `VariableContainer`를 통한 유연한 변수 저장&#10;- `PlayerPrefs` 기반 간단한 저장/불러오기 기능&#10;- 선형적 저장 히스토리 관리 시스템&#10;- Unity Editor에서 히스토리 관리 기능 제공&#10;- 박싱 회피를 위한 최적화된 변수 저장 구조&#10;&#10;---&#10;&#10;## ✏️ 변경(추가) 사항&#10;&#10;### 1) VariableContainer (변수 컨테이너)&#10;- 다양한 타입(int, float, string)의 값을 저장할 수 있는 컨테이너 클래스&#10;- `Variable` 내부 클래스로 박싱을 피하는 최적화된 구조&#10;- `SerializableDictionary`를 사용한 Unity 직렬화 지원&#10;- `SetString/SetInteger/SetFloat`: 키-값 쌍으로 변수 저장&#10;- `GetVariable/TryGetInteger/TryGetFloat/TryGetString`: 변수 조회&#10;- `HasVariable`: 변수 존재 여부 확인&#10;- `Clone()`: 깊은 복사를 통한 변수 컨테이너 복제&#10;&#10;### 2) GameData (게임 데이터 구조체)&#10;- 게임의 모든 저장 가능한 데이터를 담는 중앙 집중식 데이터 구조&#10;- **내장 변수**: &#10;  - `CurrentStage`: 현재 월드 및 스테이지 인덱스&#10;  - `TurnCount`: 턴 횟수&#10;  - `TotalScore`: 누적 총점&#10;  - `CurrentScore`: 현재 턴 점수&#10;  - `PlayerStatus`: 플레이어 상태 정보&#10;- **VariableContainer**: 추가적인 동적 변수 저장 (내장 변수 우선 사용 권장)&#10;- `SaveVariable/GetVariable/GetIntVariable/GetFloatVariable/GetStringVariable`: 변수 접근 메서드&#10;- `ContainsKey`: 변수 존재 여부 확인&#10;- `Clone()`: 데이터 복제 기능&#10;&#10;### 3) ISaveTarget 인터페이스&#10;- 저장/불러오기가 가능한 객체를 위한 인터페이스&#10;- `Guid Guid { get; init; }`: 고유 식별자&#10;- `LoadData(GameData data)`: 데이터 불러오기&#10;- `SaveData(ref GameData data)`: 데이터 저장&#10;&#10;### 4) SaveLoadManager (세이브/로드 관리자)&#10;- 싱글톤 패턴으로 구현된 중앙 집중식 저장/불러오기 관리자&#10;- `RegisterSaveTarget(ISaveTarget)`: 저장 대상 객체 등록&#10;- `UnregisterSaveTarget(ISaveTarget)`: 저장 대상 객체 등록 해제&#10;- `RegisterPendingSavable(ISaveTarget)`: 인스턴스 생성 전 등록 대기&#10;- `CreateCurrentSaveData()`: 모든 등록된 객체의 데이터를 수집하여 GameData 생성&#10;- `LoadSaveData(GameData)`: GameData를 모든 등록된 객체에 전달&#10;- **간단한 저장/불러오기**:&#10;  - `SimpleSave()`: PlayerPrefs를 사용한 빠른 저장&#10;  - `SimpleLoad(string, Action, Action)`: PlayerPrefs를 사용한 빠른 불러오기&#10;  - `HasSimpleSave()`: 저장 데이터 존재 여부 확인&#10;  - `HasSaveSimpleReliable()`: 저장 데이터 유효성 확인&#10;- `DefaultExecutionOrder(-1000)`: 다른 스크립트보다 먼저 초기화&#10;&#10;### 5) SaveHistory (저장 히스토리)&#10;- `List&lt;GameData&gt;`를 래핑한 선형 저장 히스토리 컨테이너&#10;- `IReadOnlyList&lt;GameData&gt;` 인터페이스 구현&#10;- `Add(GameData)`: 새 저장 데이터 추가 (자동 복제)&#10;- `GetLastSave()`: 마지막 저장 데이터 조회&#10;- `GetSaveAt(int)`: 특정 인덱스의 저장 데이터 조회&#10;- `PopLastSave()`: 마지막 저장 데이터 제거 및 반환&#10;- `Clear()`: 모든 히스토리 삭제&#10;&#10;### 6) HistoryManager (히스토리 관리자)&#10;- 싱글톤 패턴으로 구현된 저장 히스토리 관리자&#10;- `SaveCurrentState()`: 현재 게임 상태를 히스토리에 저장&#10;- `LoadLastSave()`: 마지막 저장 상태로 복원&#10;- `LoadAndPopLastSave()`: 마지막 저장 상태로 복원하고 히스토리에서 제거 (Undo 기능)&#10;- `ClearHistory()`: 모든 히스토리 삭제&#10;- **Unity Editor 통합**:&#10;  - Inspector에서 히스토리 관리 버튼 제공&#10;  - 메뉴바에서 `SaveLoad/Clear History` 명령 제공&#10;&#10;---&#10;&#10;## 사용 방법&#10;&#10;### 기본 세이브/로드 사용법&#10;&#10;```csharp&#10;// 1. ISaveTarget 인터페이스 구현&#10;public class PlayerController : MonoBehaviour, ISaveTarget&#10;{&#10;    public Guid Guid { get; init; } = Guid.NewGuid();&#10;    &#10;    private Vector3 playerPosition;&#10;    private int playerHealth;&#10;    &#10;    private void OnEnable()&#10;    {&#10;        SaveLoadManager.RegisterPendingSavable(this);&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        SaveLoadManager.Instance.UnregisterSaveTarget(this);&#10;    }&#10;    &#10;    // 데이터 저장&#10;    public void SaveData(ref GameData data)&#10;    {&#10;        data.SaveVariable(&quot;PlayerPosX&quot;, playerPosition.x);&#10;        data.SaveVariable(&quot;PlayerPosY&quot;, playerPosition.y);&#10;        data.SaveVariable(&quot;PlayerPosZ&quot;, playerPosition.z);&#10;        data.SaveVariable(&quot;PlayerHealth&quot;, playerHealth);&#10;    }&#10;    &#10;    // 데이터 불러오기&#10;    public void LoadData(GameData data)&#10;    {&#10;        float x = data.GetFloatVariable(&quot;PlayerPosX&quot;);&#10;        float y = data.GetFloatVariable(&quot;PlayerPosY&quot;);&#10;        float z = data.GetFloatVariable(&quot;PlayerPosZ&quot;);&#10;        playerPosition = new Vector3(x, y, z);&#10;        &#10;        playerHealth = data.GetIntVariable(&quot;PlayerHealth&quot;, 100);&#10;    }&#10;}&#10;&#10;// 2. 게임 저장&#10;public void SaveGame()&#10;{&#10;    SaveLoadManager.Instance.SimpleSave();&#10;    Debug.Log(&quot;Game Saved!&quot;);&#10;}&#10;&#10;// 3. 게임 불러오기&#10;public void LoadGame()&#10;{&#10;    bool success = SaveLoadManager.Instance.SimpleLoad(&#10;        onComplete: () =&gt; Debug.Log(&quot;Game Loaded!&quot;),&#10;        onFail: () =&gt; Debug.LogError(&quot;Failed to load game!&quot;)&#10;    );&#10;}&#10;&#10;// 4. 저장 데이터 존재 여부 확인&#10;public bool CanContinue()&#10;{&#10;    return SaveLoadManager.Instance.HasSimpleSave();&#10;}&#10;```&#10;&#10;### GameData 내장 변수 사용&#10;&#10;```csharp&#10;public class StageManager : MonoBehaviour, ISaveTarget&#10;{&#10;    public Guid Guid { get; init; } = Guid.NewGuid();&#10;    &#10;    public void SaveData(ref GameData data)&#10;    {&#10;        // 내장 변수 사용 (권장)&#10;        data.CurrentStage = new int[] { currentWorld, currentStage };&#10;        data.TurnCount = turnCount;&#10;        data.TotalScore = totalScore;&#10;        data.CurrentScore = currentScore;&#10;    }&#10;    &#10;    public void LoadData(GameData data)&#10;    {&#10;        currentWorld = data.CurrentStage[0];&#10;        currentStage = data.CurrentStage[1];&#10;        turnCount = data.TurnCount;&#10;        totalScore = data.TotalScore;&#10;        currentScore = data.CurrentScore;&#10;    }&#10;}&#10;```&#10;&#10;### 히스토리 시스템 사용법&#10;&#10;```csharp&#10;// 1. 현재 상태 저장 (체크포인트)&#10;public void CreateCheckpoint()&#10;{&#10;    HistoryManager.Instance.SaveCurrentState();&#10;    Debug.Log(&quot;Checkpoint created!&quot;);&#10;}&#10;&#10;// 2. 마지막 저장 상태로 복원 (히스토리 유지)&#10;public void RestoreCheckpoint()&#10;{&#10;    HistoryManager.Instance.LoadLastSave();&#10;    Debug.Log(&quot;Restored to last checkpoint!&quot;);&#10;}&#10;&#10;// 3. 마지막 저장 상태로 복원 및 제거 (Undo)&#10;public void UndoLastAction()&#10;{&#10;    var previousState = HistoryManager.Instance.LoadAndPopLastSave();&#10;    if (previousState != null)&#10;    {&#10;        Debug.Log(&quot;Undone!&quot;);&#10;    }&#10;}&#10;&#10;// 4. 히스토리 확인&#10;public int GetCheckpointCount()&#10;{&#10;    return HistoryManager.Instance.SaveHistory.Count;&#10;}&#10;&#10;// 5. 특정 시점으로 복원&#10;public void RestoreToCheckpoint(int index)&#10;{&#10;    var saveHistory = HistoryManager.Instance.SaveHistory;&#10;    if (index &gt;= 0 &amp;&amp; index &lt; saveHistory.Count)&#10;    {&#10;        SaveLoadManager.Instance.LoadSaveData(saveHistory[index]);&#10;    }&#10;}&#10;```&#10;&#10;### VariableContainer 직접 사용&#10;&#10;```csharp&#10;// VariableContainer를 직접 사용하는 경우&#10;public void SaveCustomData(GameData data)&#10;{&#10;    // 다양한 타입 저장&#10;    data.Variables.SetInteger(&quot;Level&quot;, 5);&#10;    data.Variables.SetFloat(&quot;ExperienceMultiplier&quot;, 1.5f);&#10;    data.Variables.SetString(&quot;PlayerName&quot;, &quot;Hero&quot;);&#10;}&#10;&#10;public void LoadCustomData(GameData data)&#10;{&#10;    // TryGet 메서드 사용&#10;    if (data.Variables.TryGetInteger(&quot;Level&quot;, out int level))&#10;    {&#10;        Debug.Log($&quot;Level: {level}&quot;);&#10;    }&#10;    &#10;    // 인덱서 사용&#10;    var variable = data.Variables[&quot;ExperienceMultiplier&quot;];&#10;    if (variable != null)&#10;    {&#10;        float multiplier = variable.FloatValue;&#10;        Debug.Log($&quot;Multiplier: {multiplier}&quot;);&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## ⭐특징 및 주의사항&#10;&#10;### 장점&#10;- **중앙 집중식 관리**: SaveLoadManager를 통한 통합 저장/불러오기 관리&#10;- **유연한 데이터 구조**: 내장 변수와 VariableContainer를 통한 확장 가능한 데이터 저장&#10;- **박싱 회피**: Variable 클래스를 통한 성능 최적화&#10;- **히스토리 시스템**: 선형적 저장 히스토리를 통한 체크포인트 및 Undo 기능&#10;- **자동 등록**: RegisterPendingSavable을 통한 초기화 순서 문제 해결&#10;- **Unity 직렬화**: SerializableDictionary와 [Serializable] 속성을 통한 Inspector 표시&#10;- **Editor 통합**: Unity Editor에서 히스토리 관리 및 디버깅 기능 제공&#10;- **안전한 불러오기**: 예외 처리와 콜백을 통한 안전한 데이터 로딩&#10;&#10;### 주의사항&#10;- **내장 변수 우선 사용**: GameData의 내장 변수를 우선적으로 사용하고, 동적 데이터만 VariableContainer 사용&#10;- **Guid 관리**: ISaveTarget 구현 시 고유한 Guid가 필요 (현재는 사용되지 않지만 추후 확장 가능)&#10;- **등록/해제 필수**: OnEnable/OnDisable에서 반드시 SaveTarget을 등록/해제해야 함&#10;- **히스토리 메모리**: SaveHistory는 GameData를 복제하여 저장하므로 메모리 사용량 고려 필요&#10;- **PlayerPrefs 한계**: SimpleSave는 PlayerPrefs를 사용하므로 대용량 데이터에는 부적합&#10;- **ref 키워드**: SaveData 메서드는 `ref GameData`를 사용하여 구조체 복사 비용 감소&#10;- **DefaultExecutionOrder**: SaveLoadManager는 -1000 순서로 다른 스크립트보다 먼저 초기화됨&#10;&#10;### 확장 가능성&#10;- 현재는 PlayerPrefs를 사용하지만, 파일 시스템이나 클라우드 저장으로 쉽게 확장 가능&#10;- Guid를 활용한 개별 객체 저장/불러오기 구현 가능&#10;- SaveHistory에 메타데이터(저장 시간, 스테이지 정보 등) 추가 가능&#10;- 암호화나 압축 기능 추가 가능&#10;&#10;---&#10;&#10;## ⚠️알려진 문제 (Known Issues)&#10;&#10;- `ISaveData` 인터페이스가 정의되어 있지만 현재 사용되지 않음 (추후 확장용)&#10;- `Guid`가 ISaveTarget에 정의되어 있지만 현재 SaveLoadManager에서 활용되지 않음&#10;- PlayerPrefs의 저장 크기 제한으로 인해 대용량 데이터 저장 시 문제 발생 가능&#10;- SaveHistory가 무제한 증가할 수 있어 메모리 관리 필요 (최대 개수 제한 고려)&#10;&#10;--- &#10;&#10;## ✅ 체크리스트&#10;- [x] Namespace 규칙 확인 (SaveLoad)&#10;- [x] public 함수의 경우 주석 확인&#10;- [x] 박싱 회피를 위한 최적화 적용&#10;- [x] Unity 직렬화 지원&#10;- [x] Editor 통합 기능 제공&#10;&#10;---&#10;&#10;## 연관 PR&#10;&#10;(없음)&#10;&#10;---&#10;&#10;## 연관 이슈&#10;&#10;(없음)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>